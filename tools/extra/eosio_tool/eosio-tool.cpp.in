// Declares clang::SyntaxOnlyAction.
#include "clang/Frontend/FrontendActions.h"
#include "clang/Tooling/CommonOptionsParser.h"
#include "clang/Tooling/Tooling.h"
#include "clang/Rewrite/Core/Rewriter.h"

#include <iostream>
#include <sstream>

#include "llvm/Support/CommandLine.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/Path.h"
#include "llvm/Support/Program.h"

using namespace clang::tooling;
using namespace llvm;

#include "tool_options.hpp"
#include "generator.hpp"

namespace eosio { namespace cdt {
class eosio_tool {
   public:
      static constexpr uint8_t error = -1;
      static constexpr uint8_t success = 0;
      eosio_tool( const std::string& name ) : this_name(name) {}
      inline bool is_eosio_cc()const { return this_name == "eosio-cc"; }
      inline bool is_eosio_cpp()const { return this_name == "eosio-cpp"; }
      inline bool is_eosio_ld()const { return this_name == "eosio-ld"; }
      inline bool is_eosio_abigen()const { return this_name == "eosio-abigen"; }
      inline bool is_eosio_tool()const { return this_name == "eosio-tool"; }
      tool_type   get_type()const { 
         if (is_eosio_cpp())
            return CXX;
         if (is_eosio_ld())
            return LD;
         if (is_eosio_abigen())
            return ABIGEN;
         if (is_eosio_cc())
            return CC;
         return TOOL;
      }

      inline std::string help_msg()const {
         if ( is_eosio_cc() )
            return "Eosio C -> WebAssembly C Compiler";
         else if ( is_eosio_cpp() )
            return "Eosio C++ -> WebAssembly C++ Compiler";
         else if ( is_eosio_ld() )
            return "Eosio LD -> WebAssembly Loader/Linker";
         else if ( is_eosio_abigen() )
            return "Eosio ABIGen -> Eosio ABI generator";
      }

      inline bool exists( const std::string& fn )const { return llvm::sys::fs::exists(fn); }

      int run_linker( tool_options& tool_opts ) {
         tool_opts.ld_options.emplace_back(tool_opts.output_filename);
         tool_opts.ld_options.emplace_back("-o "+tool_opts.output_filename);
         tool_opts.ld_options.emplace_back("-lc++ -lc -leosio");

         if (!eosio::cdt::environment::exec_subprogram("wasm-ld", tool_opts.ld_options))
            return error;
         if ( !llvm::sys::fs::exists( tool_opts.output_filename ) )
            return error;

         if (!eosio::cdt::environment::exec_subprogram("eosio-pp", {tool_opts.output_filename}))
            return error;
         if (!llvm::sys::fs::exists(tool_opts.output_filename))
            return error;
         return success;
      }

      int run( int argc, const char** argv ) {
         if (is_eosio_tool()) {
            std::cerr << "This tool can't be called directly, use <eosio-cpp, eosio-cc, eosio-ld or eosio-abigen>\n";
            return error;
         }
         cl::SetVersionPrinter([&](llvm::raw_ostream& os) {
               os << this_name << " version " << ${EOSIO_VER_MAJOR} << "." << ${EOSIO_VER_MINOR} << "." << ${EOSIO_VER_REVISION} << "\n";
         });


         std::vector<std::string> options;
         for ( int i=0; i < argc; i++ )
            options.push_back(argv[i]);

         tool_options tool_opts(get_type());
         if ( is_eosio_cc() || is_eosio_cpp() || is_eosio_abigen() ) {
            tool_options::get_comp_defaults(options);
         } else {
            tool_options::get_ld_defaults(options);
         }

         cl::ParseCommandLineOptions(argc, argv, "("+help_msg()+")");
         tool_opts.run();

         std::vector<std::string> new_args = {options[0]};
         options.erase(options.begin());
         for ( auto in : tool_opts.inputs )
            new_args.push_back(in.c_str());
         new_args.push_back("--");
         for ( int i=0; i < tool_opts.comp_options.size(); i++ )
           new_args.push_back(tool_opts.comp_options[i].c_str()); 
         tool_options::get_comp_defaults(new_args);
         for ( int i=0; i < new_args.size(); i++ )
            std::cout << new_args[i] << '\n';

         const char* new_argv[new_args.size()];
         for ( int i=0; i < new_args.size(); i++ )
            new_argv[i] = new_args[i].c_str();
         llvm::cl::OptionCategory null_cat("null options");
         int size = new_args.size();
         CommonOptionsParser opts( size, new_argv, null_cat, 0 );

         if ( is_eosio_abigen() || tool_opts.abigen ) {
            ClangTool tool( opts.getCompilations(), opts.getSourcePathList());
            get_abigen_ref().set_contract_name(tool_opts.abigen_contract);
            EosioMethodMatcher eosio_method_matcher;
            EosioRecordMatcher eosio_record_matcher;
            MatchFinder finder;
            finder.addMatcher(function_decl_matcher, &eosio_method_matcher);
            finder.addMatcher(record_decl_matcher, &eosio_record_matcher);
            finder.addMatcher(class_tmp_matcher, &eosio_record_matcher);

            try {
               if (tool.run(newFrontendActionFactory(&finder).get()) == error)
                  return error;
               std::string outs = tool_opts.abigen_output.empty() ? tool_opts.output_filename.substr(0, tool_opts.output_filename.rfind(".wasm"))+".abi" : tool_opts.abigen_output;
               std::ofstream output(outs);
               output << pretty_print(get_abigen_ref().to_json());
               output.close();
            } catch ( const std::exception& ex) {
               std::cerr << ex.what() << "\n";
               return error;
            } catch (const std::string& s) {
               std::cerr << s << "\n";
               return error;
            }
            if (is_eosio_abigen())
               return success;
         }

         if ( is_eosio_cc() || is_eosio_cpp() ) {
            for (auto def : options) {
               if (def != "--")
                  tool_opts.comp_options.push_back(def);
            }
            tool_opts.comp_options.emplace_back("-c ");
            tool_opts.comp_options.emplace_back("-o "+tool_opts.output_filename);

            if ( !eosio::cdt::environment::exec_subprogram("clang-7", tool_opts.comp_options) )
               return error;
            if ( !exists(tool_opts.output_filename) )
               return error;

            if ( tool_opts.link ) {
               tool_options::get_ld_defaults(tool_opts.ld_options);
               return run_linker(tool_opts);
            }
         }
         /*
         if ( is_eosio_abigen() || tool_opts.abigen ) {
            tool_opts.abigen_options.emplace(tool_opts.abigen_options.begin(), "-- -Wno-unused-command-line-argument");
            tool_opts.abigen_options.emplace(tool_opts.abigen_options.begin(), "-contract="+tool_opts.abigen_contract);
            std::string abigen_output = tool_opts.abigen_output.empty() ? tool_opts.output_fn.substr(0, tool_opts.output_fn.rfind(".wasm"))+".abi" : tool_opts.abigen_output;
            tool_opts.abigen_options.emplace(tool_opts.abigen_options.begin(), "-output="+abigen_output);
            tool_opts.abigen_options.insert(tool_opts.abigen_options.begin(), tool_opts.abigen_inputs);
            if (!eosio::cdt::environment::exec_subprogram("eosio-abigen", tool_opts.abigen_options))
               return -1;
         }
         */
         return success;
      }
   private:
      clang::Rewriter rewriter;
      std::string this_name = "eosio-tool";
};

}} // ns eosio::cdt

int main(int argc, const char **argv) {
   eosio::cdt::eosio_tool etool(llvm::sys::path::filename(argv[0]).str());
   return etool.run(argc, argv);
}
