#pragma once
#include "eosio/utils.hpp"
#include "eosio/whereami/whereami.hpp"
#include "llvm/Support/FileSystem.h"
#include <vector>
#include <string>
#include <functional>

#define HIDDEN_OPT(TYPE, OPT_NAME, NAME, MSG, CAT, CB) \
   static cl::opt<TYPE> OPT_NAME(#NAME, cl::desc(MSG), cl::Hidden, cl::cat(CAT)); option_callbacks.push_back(CB)
#define OPT(TYPE, OPT_NAME, NAME, MSG, CAT, CB) \
   static cl::opt<TYPE> OPT_NAME(#NAME, cl::desc(MSG), cl::cat(CAT)); option_callbacks.push_back(CB)

#define PREOPT(TYPE, OPT_NAME, NAME, MSG, CAT, CB) \
   static cl::opt<TYPE> OPT_NAME(#NAME, cl::desc(MSG), cl::Prefix, cl::cat(CAT)); option_callbacks.push_back(CB)

#define PREOPTO(TYPE, OPT_NAME, NAME, MSG, OCCURRENCE, CAT, CB) \
   static cl::opt<TYPE> OPT_NAME(#NAME, cl::desc(MSG), cl::Prefix, OCCURRENCE, cl::cat(CAT)); option_callbacks.push_back(CB)

#define LIST(TYPE, OPT_NAME, NAME, MSG, OCCURRENCE, CAT, CB) \
   static cl::list<TYPE> OPT_NAME(#NAME, cl::desc(MSG), OCCURRENCE, cl::cat(CAT)); option_callbacks.push_back(CB)

#define POSLIST(TYPE, OPT_NAME, MSG, OCCURRENCE, CAT, CB) \
   static cl::list<TYPE> OPT_NAME(cl::Positional, cl::desc(MSG),  OCCURRENCE, cl::cat(CAT)); option_callbacks.push_back(CB)

#define PRELIST(TYPE, OPT_NAME, NAME, MSG, OCCURRENCE, CAT, CB) \
   static cl::list<TYPE> OPT_NAME(#NAME, cl::desc(MSG), OCCURRENCE, cl::Prefix, cl::cat(CAT)); option_callbacks.push_back(CB)


namespace eosio { namespace cdt {

enum tool_type {
   CC,
   CXX,
   LD,
   ABIGEN,
   TOOL
};

struct tool_options {
   llvm::cl::OptionCategory options_cat = llvm::cl::OptionCategory("eosio tool options");
   std::string output_filename;
   bool link = true;
   bool abigen = false;
   std::string eosio_pp_dir;
   std::string abigen_output;
   std::string abigen_contract;
   std::vector<std::string> inputs;
   std::vector<std::string> comp_options;
   std::vector<std::string> ld_options;
   std::vector<std::function<void()>> option_callbacks;
   tool_options(tool_type type) {
      switch ( type ) {
         case TOOL:
         case ABIGEN:
         case CXX:
            OPT(std::string, std_opt, 
                  std, "Language standard to compile for", options_cat,
                  [&]() {
                     if ( !std_opt.empty() ) 
                        comp_options.emplace_back("--std"+std_opt);
                     else
                        comp_options.emplace_back("--std=c++17");
            });
            OPT(bool, faligned_allocation_opt, 
                  faligned-allocation, "Enable C++17 aligned allocation functions", options_cat,
                  [&]() {
                     if (faligned_allocation_opt)
                        comp_options.emplace_back("-faligned-allocation");
            });
            OPT(bool, fcoroutine_ts_opt, 
                  fcoroutine-ts, "Enable support for the C++ Coroutines TS", options_cat,
                  [&]() {
                     if (fcoroutine_ts_opt)
                        comp_options.emplace_back("-fcoroutine-ts");
            });
            OPT(bool, fno_elide_constructors_opt, 
                  fno-elide-constructors, "Disable C++ copy constructor elision", options_cat,
                  [&]() {
                     if (fno_elide_constructors_opt)
                        comp_options.emplace_back("-fno-elide-constructors");
            });
            OPT(bool, fstrict_vtable_pointers_opt, 
                  fstrict-vtable-pointers, "Enable optimizations based on the strict rules for overwriting polymorphic C++ objects", options_cat,
                  [&]() {
                     if (fstrict_vtable_pointers_opt)
                        comp_options.emplace_back("-fstrict-vtable-pointers");
            });
         case CC:
            OPT(bool, abigen_opt, 
                  abigen, "Generate ABI", options_cat,
                  [&]() {
                     abigen = abigen_opt;
            });
            OPT(std::string, abigen_output_opt, 
                  abigen-output, "abigen output", options_cat,
                  [&]() {
                     abigen_output = abigen_output_opt;
            });
            OPT(bool, g_opt, 
                  g, "debug build <ignored>", options_cat, [&](){});
            PREOPT(std::string, x_opt, 
                  x, "<ignored>", options_cat, [&](){});
            OPT(bool, pch_opt, 
                  fpch-preprocess, "<ignored>", options_cat, [&](){});
            OPT(bool, CC_opt, 
                  CC, "Include comments from within macros in preprocessed output", options_cat,
                  [&](){
                     if (CC_opt)
                        comp_options.emplace_back("-CC");
            });
            OPT(bool, C_opt, 
                  C, "Include comments in preprocessed output", options_cat,
                  [&]() {
                     if (C_opt)
                        comp_options.emplace_back("-C");
            });
            OPT(bool, c_opt, 
                  c, "Only run preprocess, compile, and assemble steps", options_cat,
                  [&]() {
                     if (c_opt) {
                        comp_options.emplace_back("-c");
                        link = false;
                     }
            });
            OPT(bool, color_diag_opt, 
                  fcolor-diagnostics, "Use colors in diagnostics", options_cat,
                  [&]() {
                     if (color_diag_opt)
                        comp_options.emplace_back("-fcolor-diagnostics");
            });
            OPT(bool, dD_opt, 
                  dD, "Print macro definitions in -E mode in addition to normal output", options_cat,
                  [&]() {
                     if (dD_opt)
                        comp_options.emplace_back("-dD");
            });
            OPT(bool, dI_opt, 
                  dI, "Print macro definitions in -E mode in addition to normal output", options_cat,
                  [&]() {
                     if (dI_opt)
                        comp_options.emplace_back("-dI");
            });
            OPT(bool, dM_opt, 
                  dM, "Print macro definitions in -E mode in addition to normal output", options_cat,
                  [&](){
                     if (dM_opt)
                        comp_options.emplace_back("-dM");
            });
            PRELIST(std::string, D_opt,
                  D, "Define <macro> to <value> (or 1 if <value> omitted)", cl::ZeroOrMore, options_cat,
                  [&]() {
                     for (auto define : D_opt)
                        comp_options.emplace_back("-D"+define);
            });
            OPT(bool, emit_ast_opt, 
                  emit-ast, "Emit Clang AST files for source inputs", options_cat,
                  [&]() {
                     if (emit_ast_opt)
                        comp_options.emplace_back("-emit-ast");
            });
            OPT(bool, emit_llvm_opt, 
                  emit-llvm, "Use the LLVM representation for assembler and object files", options_cat,
                  [&]() {
                  if (emit_llvm_opt)
                     comp_options.emplace_back("-emit-llvm");
            });
            OPT(bool, E_opt, 
                  E, "Only run the preprocessor", options_cat,
                  [&]() {
                     if (E_opt)
                        comp_options.emplace_back("-E");
            });
            OPT(bool, finline_functions_opt, 
                  finline-functions, "Inline suitable functions", options_cat,
                  [&]() {
                     if (finline_functions_opt)
                        comp_options.emplace_back("-finline-functions");
            });
            OPT(bool, finline_hint_functions_opt, 
                  finline-hint-functions, "Inline suitable functions", options_cat,
                  [&]() {
                     if (finline_hint_functions_opt)
                        comp_options.emplace_back("-finline-hint-functions");
            });
            OPT(bool, fmerge_all_constants_opt, 
                  fmerge-all-constants, "Allow merging of constants", options_cat,
                  [&]() {
                     if (fmerge_all_constants_opt)
                        comp_options.emplace_back("-fmerge-all-constants");
            });
            OPT(bool, fstack_protector_all_opt, 
                  fstack-protector-all, "Force the usage of stack protectors for all functions", options_cat,
                  [&]() {
                     if (fstack_protector_all_opt)
                        comp_options.emplace_back("-fstack-protector-all");
            });
            OPT(bool, fstack_protector_strong_opt, 
                  fstack-protector-strong, "Use a strong heuristic to apply stack protectors to functions", options_cat,
                  [&]() {
                     if (fstack_protector_strong_opt)
                        comp_options.emplace_back("-fstack-protector-strong");
            });
            OPT(bool, fstack_protector_opt, 
                  fstack-protector, "Enable stack protectors for functions potentially vulnerable to stack smashing", options_cat,
                  [&]() {
                     if (fstack_protector_opt)
                        comp_options.emplace_back("-fstack-protector");
            });
            OPT(bool, fstrict_enums_opt, 
                  fstrict-enums, "Enable optimizations based on the strict definition of an enum's value range", options_cat,
                  [&]() {
                     if (fstrict_enums_opt)
                        comp_options.emplace_back("-fstrict-enums");
            });
            OPT(bool, fstrict_return_opt, 
                  fstrict-return, "Always treat control flow paths that fall off the end of a non-void function as unreachable", options_cat,
                  [&]() {
                     if (fstrict_return_opt)
                        comp_options.emplace_back("-fstrict-return");
            });
            LIST(std::string, include_opt,
                  include, "Include file before parsing", cl::ZeroOrMore, options_cat,
                  [&]() {
                     for (auto inc : include_opt)
                        comp_options.emplace_back("-include="+inc);
            });
            PRELIST(std::string, I_opt,
                  I, "Add directory to include search path", cl::ZeroOrMore, options_cat,
                  [&]() {
                     for (auto inc : I_opt)
                        comp_options.emplace_back("-I"+inc);
            });
            PREOPTO(std::string, O_opt,
                  O, "Optimization level s, 0-3", cl::ZeroOrMore, options_cat,
                  [&]() {
                     if (O_opt.empty())
                        comp_options.emplace_back("-O3");
                     else
                        comp_options.emplace_back("-O"+O_opt);
            });
            PREOPT(std::string, sysroot_opt,
                  sysroot, "Set the system root directory", options_cat,
                  [&]() {
                     if (!sysroot_opt.empty()) {
                        comp_options.emplace_back("--sysroot "+sysroot_opt);
                        comp_options.emplace_back("-I"+sysroot_opt+"/include/libcxx");
                        comp_options.emplace_back("-I"+sysroot_opt+"/include/libc");
                        ld_options.emplace_back("-L"+sysroot_opt+"/lib");
                        ld_options.emplace_back("-L"+sysroot_opt+"/lib64");
                     } else {
                        comp_options.emplace_back("--sysroot "+eosio::cdt::whereami::where()+"/../");
                        comp_options.emplace_back("-I"+eosio::cdt::whereami::where()+"/../include/libcxx");
                        comp_options.emplace_back("-I"+eosio::cdt::whereami::where()+"/../include/libc");
                        ld_options.emplace_back("-L"+eosio::cdt::whereami::where()+"/../lib");
                        ld_options.emplace_back("-L"+eosio::cdt::whereami::where()+"/../lib64");
                     }
            });
            PREOPT(std::string, isysroot_opt,
                  isysroot, "Set the system root directory", options_cat, [&](){});
            PREOPT(std::string, isystem_opt,
                  isystem, "Add directory to SYSTEM include search path", options_cat,
                  [&]() {
                     if (!isystem_opt.empty())
                        comp_options.emplace_back("-isystem="+isystem_opt);
            });
            OPT(bool, S_opt, 
                  S, "Only run preprocess and compilation steps", options_cat,
                  [&]() {
                     if (S_opt) {
                        comp_options.emplace_back("-S");
                        link = false;
                     }
            });
            OPT(std::string, U_opt, 
                  U, "Undefine macro <macro>", options_cat,
                  [&]() {
                     if (!U_opt.empty())
                        comp_options.emplace_back("-U="+U_opt);
            });
            OPT(bool, v_opt, 
                  v, "Show commands to run and use verbose output", options_cat,
                  [&]() {
                     if (v_opt)
                        comp_options.emplace_back("-v");
            });
            OPT(bool, w_opt, 
                  w, "Suppress all warnings", options_cat,
                  [&]() {
                     if (w_opt)
                        comp_options.emplace_back("-w");
            });
            PRELIST(std::string, W_opt,
                  W, "Enable the specified warning", cl::ZeroOrMore, options_cat,
                  [&]() {
                     for (auto warn : W_opt)
                        comp_options.emplace_back("-W"+warn);
            });
            OPT(std::string, contract_name,
                  contract, "Contract name", options_cat,
                  [&]() {
                     if (!contract_name.empty())
                        abigen_contract = contract_name;
                     else
                        abigen_contract = output_filename.substr(0, output_filename.rfind(".wasm"));
            });
         case LD:
            HIDDEN_OPT(std::string, eosio_imports_opt, 
                  eosio-imports, "Set the file for eosio.imports", options_cat,
                  [&]() {
                     if (!eosio_imports_opt.empty())
                        ld_options.emplace_back("--allow-undefined-file="+eosio_imports_opt);
                     else
                        ld_options.emplace_back("--allow-undefined-file="+eosio::cdt::whereami::where()+"/../eosio.imports");
            });
            HIDDEN_OPT(std::string, pp_path_opt, 
                  eosio-pp-dir, "Set the directory for eosio-pp", options_cat,
                  [&]() {
                     if (!pp_path_opt.empty())
                        eosio_pp_dir = pp_path_opt;
                     else
                        eosio_pp_dir = eosio::cdt::whereami::where();
            });
            OPT(std::string, lto_opt_opt, 
                  lto-O, "LTO Optimization level (O0-O3)", options_cat,
                  [&]() {
                     if (!lto_opt_opt.empty())
                        ld_options.emplace_back("--lto-O"+lto_opt_opt);
            });
            OPT(bool, fno_lto_opt, 
                  fno-lto, "Disable LTO", options_cat,
                  [&]() {
                     if (fno_lto_opt)
                        ld_options.emplace_back("--lto-O0");
                     else
                        ld_options.emplace_back("--lto-O3");
            });
            PRELIST(std::string, L_opt, 
                  L, "Add directory to library search path", cl::ZeroOrMore, options_cat,
                  [&]() {
                     for (auto lib_dir : L_opt)
                        ld_options.emplace_back("-L"+lib_dir);
            });
            PRELIST(std::string, l_opt, 
                  l, "Root name of library to link", cl::ZeroOrMore, options_cat,
                  [&]() {
                     for (auto lib : l_opt)
                        ld_options.emplace_back("-l"+lib);
            });
            OPT(std::string, o_opt, 
                  o, "Write output to <file>", options_cat,
                  [&]() {
                     if (o_opt.empty())
                        output_filename = "a.out";
                     else
                        output_filename = o_opt;
            });
      };
   } 

   void run() {
      for ( auto cb = option_callbacks.rbegin(); cb != option_callbacks.rend(); cb++ )
         (*cb)();
   }

   static void get_comp_defaults(std::vector<std::string>& copts, bool CXX=true) {
      const char* eosio_apply_suff = "${CMAKE_SHARED_LIBRARY_SUFFIX}";
      std::string apply_lib;
      copts.emplace_back("-Wno-unused-command-line-argument");
      copts.emplace_back("--target=wasm32");
      copts.emplace_back("-nostdlib");
      copts.emplace_back("-ffreestanding");
      copts.emplace_back("-fno-builtin");
      copts.emplace_back("-fno-threadsafe-statics");
      if (CXX) {
         copts.emplace_back("-fno-rtti");
         copts.emplace_back("-fno-exceptions");
      }
      copts.emplace_back("-DBOOST_DISABLE_ASSERTS");
      copts.emplace_back("-DBOOST_EXCEPTION_DISABLE");
      copts.emplace_back("-Xclang");
      copts.emplace_back("-load");
      copts.emplace_back("-Xclang");
      if (llvm::sys::fs::exists(eosio::cdt::whereami::where()+"/LLVMEosioApply"+eosio_apply_suff))
         copts.emplace_back(eosio::cdt::whereami::where()+"/LLVMEosioApply"+eosio_apply_suff);
      else if (llvm::sys::fs::exists(eosio::cdt::whereami::where()+"/../lib/LLVMEosioApply"+eosio_apply_suff))
         copts.emplace_back(eosio::cdt::whereami::where()+"/../lib/LLVMEosioApply"+eosio_apply_suff);

      if (llvm::sys::fs::exists(eosio::cdt::whereami::where()+"/eosio_plugin"+eosio_apply_suff))
         copts.emplace_back("-fplugin="+eosio::cdt::whereami::where()+"/eosio_plugin"+eosio_apply_suff);
      else if (llvm::sys::fs::exists(eosio::cdt::whereami::where()+"/../lib/eosio_plugin"+eosio_apply_suff))
         copts.emplace_back("-fplugin="+eosio::cdt::whereami::where()+"/../lib/eosio_plugin"+eosio_apply_suff);
   }

   static void get_ld_defaults(std::vector<std::string>& ldopts) {
      ldopts.emplace_back("-e apply");
      ldopts.emplace_back("--gc-sections");
      ldopts.emplace_back("--color-diagnostics");
      ldopts.emplace_back("-stack-first");
      ldopts.emplace_back("--strip-all");
      ldopts.emplace_back("-zstack-size="+std::string("${EOSIO_STACK_SIZE}"));
      ldopts.emplace_back("--merge-data-segments");
   }
};

}} //ns eosio::cdt
